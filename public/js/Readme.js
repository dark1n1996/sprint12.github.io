
/* REVIEW. Резюме. Что нужно исправить прежде всего.

1.Прежде всего Вы должны задать правильную структуру Вашему файлу-точке входа всего проекта script.js. Этот файл -
инициализирует весь проект, можно сказать запускает его на выполнение.
В этом файле не должно быть объявления классов (оно у Вас есть в других файлах). В нем так же не должно быть объявления каких-либо функций.
Все нужные функции должны быть методами подходящих для них классов (для этого мы и разбиваем код на классы,
чтобы всё, относящееся к одной сущности было в одном месте и не зависело от других сущностей, что облегчает сопровождение проекта).
Зато в этом файле-точке входа должно присутствовать создание экземпляров всех классов с помощью инструкции new.
Также этот файл script.js должен содержать объявление всех констант (исходных данных проекта), нужных для работы проекта.
Определение констант из constans.js надо так же перенести в script.js, а constans.js не использовать.
При создании экземпляров классов, Вы должны этим экземплярам передать в качестве аргументов нужные константы, которые определены в script.js,
а так же экземпляры других классов, или их отдельные методы и свойства (учтите, пожалуйста, что создание экземпляров одних классов в других
классах, также недопустимо, комментарий по этому поводу ещё смотрите в файле CardList.js).

2.Также Вы можете в script.js вызывать методы классов, выполнение которых необходимо сразу после загрузки страницы. В script.js также можно осуществить
добавление к элементам обработчиков событий с помощью addEentListener, используя при этом методы, определённые в классах
(используя их с экземплярами классов).

3. Весь код script.js должен быть обёрнут в IIEF функцию.  То есть весь код, не содержащий объявления классов, содержащий
только объявление констант, экземпляров классов, и возможно добавление слушателей, нужно обёртывать в IIFE функцию или просто
какую-либо функцию, для того, чтобы объявленные в нём переменные и константы не находились в глобальной области
видимости и не могли конфликтовать с переменными и функциями возможно загружаемых других (не Ваших) скриптов.
При этом нужно помнить, что после обёртывания константы и экземпляры классов, которые находились в глобальной области видимости,
будут недоступны и Вашим классам. Поэтому после обёртывания, их надо передавать как аргументы при создании экземпляра класса, определив
нужные параметры класса при объявлении кода класса.

  Чтобы понять как обертывание в IIFE защищает содержимое обёртки от глобальной области видимости, можете сами проделать следующий эксперимент:

  Пусть у Вас в index.html загружается два скрипта друг за другом: script1.js и script2.js. И в script1.js следующий код:

  function arithmetic(a, b){
    return console.log(a + b);
  };
  arithmetic(2, 3);

  А в script2.js следующий код:

  function arithmetic(a, b){
    return console.log(a * b);
  };
  arithmetic(2, 3);

  Скрипт script2.js при загрузке скриптов переопределит функцию arithmetic в первом скрипте, и при выполнении команды arithmetic(2, 3); в первом скрипте,
  будет выполняться умножение, а не сложение. Если бы код первого скрипта был обёрнут в IIFE функцию, например так:

  (function () {
  function arithmetic(a, b){
    return console.log(a + b);
  };
  arithmetic(2, 3);
  })();

переопределения бы не произошло, потому что интерпретатор js посчитал бы, что функции arithmetic в первом и во втором скрипте -
разные функции, так как у них разные обласи видимости (локальная в первом скрипте и глобальная во втором).


По обертыванию кода  в IIFE функцию даны развёрнутые пояснения в REVIEW в этом файле.
Об IIFE функциях можно почитать здесь https://learn.javascript.ru/closures-module , здесь
https://developer.mozilla.org/ru/docs/%D0%A1%D0%BB%D0%BE%D0%B2%D0%B0%D1%80%D1%8C/IIFE и
здесь https://habr.com/ru/company/ruvds/blog/419997/

*/